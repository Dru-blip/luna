# Luna language

Luna is dynamically typed programming language inspired from JavaScript that runs on register based virtual machine implemented in C.

currently it produces very unoptimized bytecode instructions.

### current execution pipeline:

- source code gets parsed into ast (classic stuff) like every other language does.
- ast gets passed to the generator which builds a simple cfg (control flow graph) of basic blocks containing a sequence of instructions.
- generator linearizes these basic blocks into a single array of instructions.
- generator packs the constants,identifiers,instructions and other data into an executable object.
- which then loaded into the virtual machine and execute it.

luna example for fibonacci:

```
fn fib(n){
    if(n<2){
        return n
    }
    return fib(n-1)+fib(n-2)
}

let a=fib(35)
print("fib 35 : ",a)

```

- and the instructions generated by the compiler.
- the instruction printer is not really good right now, but i will make it print more readable instructions later.

```
Executable<fib> (./fib.luna):{
  Max registers : 18
  Constants (3)

Instructions:
	 0000: LoadConst r3 [const 0]
	 0001: TestLt r4 <- r1 cmp r3
	 0002: JumpIf r4 goto 15 else goto 17
	 0003: LoadGlobalByIndex r6, global[0]
	 0004: LoadConst r8 [const 1]
	 0005: Sub r9 <- r1 , r8
	 0006: Call r10 <- r6()
	 0007: LoadGlobalByIndex r11, global[0]
	 0008: LoadConst r13 [const 2]
	 0009: Sub r14 <- r1 , r13
	 0010: Call r15 <- r11()
	 0011: Add r16 <- r10 , r15
	 0012: Ret r16
	 0013: LoadNone r17
	 0014: Ret r17
	 0015: Ret r1
	 0016: Jump 3
	 0017: Jump 3
}

Executable<<module>> (./fib.luna):{
  Max registers : 9
  Constants (3)

Instructions:
	 0000: MakeFunction r1 e[0] names[0]
	 0001: StoreGlobalByIndex global[0] r1
	 0002: LoadGlobalByIndex r2, global[0]
	 0003: LoadConst r3 [const 1]
	 0004: Call r4 <- r2()
	 0005: StoreGlobalByIndex global[1] r4
	 0006: LoadGlobalByName r5, names[1]
	 0007: LoadConst r6 [const 2]
	 0008: LoadGlobalByIndex r7, global[1]
	 0009: Call r8 <- r5()
	 0010: Hlt
}
```
